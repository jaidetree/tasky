// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Task from "./Task.res.mjs";
import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.res.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as DateTime from "./DateTime.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Signals from "@preact/signals";

var Task$1 = {};

var NewTask = {};

var Tasks = {};

var App = {};

var Actions = {
  Task: Task$1,
  NewTask: NewTask,
  Tasks: Tasks,
  App: App
};

var actionSignal = Signals.signal("Init");

function reduce(prevState, action) {
  var exit = 0;
  if (typeof action !== "object") {
    if (action === "Init") {
      return prevState;
    }
    exit = 2;
  } else {
    exit = 2;
  }
  if (exit === 2) {
    if (typeof prevState !== "object") {
      if (typeof action !== "object" || action.TAG !== "Open") {
        return prevState;
      } else {
        return {
                TAG: "Fetching",
                _0: Task.fetchTask(action._0)
              };
      }
    }
    switch (prevState.TAG) {
      case "Fetching" :
          if (typeof action !== "object" || action.TAG !== "Fetched") {
            return prevState;
          } else {
            return {
                    TAG: "Idle",
                    _0: action._0
                  };
          }
      case "Error" :
          break;
      case "Idle" :
          if (typeof action !== "object") {
            if (action === "ClockIn") {
              return {
                      TAG: "Running",
                      _0: prevState._0,
                      _1: {
                        id: "",
                        start_time: DateTime.now(),
                        end_time: undefined,
                        notes: "",
                        interrupted_by_task_id: undefined
                      }
                    };
            } else {
              return prevState;
            }
          }
          switch (action.TAG) {
            case "Open" :
                return prevState;
            case "Fetched" :
                break;
            case "UpdateTask" :
                return {
                        TAG: "Idle",
                        _0: action._0
                      };
            
          }
          break;
      case "Running" :
          var session = prevState._1;
          var task = prevState._0;
          if (typeof action !== "object") {
            if (action === "ClockIn") {
              return prevState;
            } else {
              return {
                      TAG: "Idle",
                      _0: {
                        id: task.id,
                        title: task.title,
                        notes: task.notes,
                        estimated_time: task.estimated_time,
                        due_date: task.due_date,
                        completed_at: task.completed_at,
                        created_at: task.created_at,
                        updated_at: task.updated_at,
                        parent_task_id: task.parent_task_id,
                        tracked_time: task.tracked_time,
                        time_sessions: Belt_Array.concatMany([
                              task.time_sessions,
                              [{
                                  id: session.id,
                                  start_time: session.start_time,
                                  end_time: DateTime.now(),
                                  notes: session.notes,
                                  interrupted_by_task_id: session.interrupted_by_task_id
                                }]
                            ])
                      }
                    };
            }
          }
          switch (action.TAG) {
            case "Open" :
                return prevState;
            case "Fetched" :
                break;
            case "UpdateTask" :
                return {
                        TAG: "Running",
                        _0: action._0,
                        _1: session
                      };
            
          }
          break;
      
    }
  }
  return prevState;
}

function dispatch(action) {
  actionSignal.value = {
    TAG: "OpenTask",
    _0: action
  };
}

var TaskFSM = {
  reduce: reduce,
  dispatch: dispatch
};

function reduce$1(prevState, action) {
  if (typeof action !== "object" && action === "Init") {
    return prevState;
  }
  if (typeof prevState !== "object") {
    if (typeof action !== "object" && action === "Create") {
      return {
              TAG: "Active",
              _0: {
                id: "",
                title: "",
                notes: "",
                estimated_time: 0,
                due_date: undefined,
                completed_at: undefined,
                created_at: "",
                updated_at: undefined,
                parent_task_id: undefined,
                tracked_time: 0,
                time_sessions: []
              }
            };
    } else {
      return prevState;
    }
  }
  if (prevState.TAG !== "Active") {
    if (typeof action !== "object" || action.TAG !== "Saved") {
      return prevState;
    } else {
      return "Inactive";
    }
  }
  if (typeof action === "object") {
    if (action.TAG === "Update") {
      return {
              TAG: "Active",
              _0: action._0
            };
    } else {
      return prevState;
    }
  }
  if (action === "Create") {
    return prevState;
  }
  var promise = Task.createTask(prevState._0);
  return {
          TAG: "Saving",
          _0: promise.then(function (task) {
                actionSignal.value = {
                  TAG: "NewTask",
                  _0: {
                    TAG: "Saved",
                    _0: task
                  }
                };
                return Promise.resolve(task);
              })
        };
}

var NewTaskFSM = {
  reduce: reduce$1
};

var actionSignal$1 = Signals.signal("Init");

function reduce$2(prevState, action) {
  if (typeof prevState === "object") {
    if (prevState.TAG === "Loading" && typeof action === "object") {
      return {
              TAG: "Tasks",
              _0: {
                tasks: action._0
              }
            };
    } else {
      return prevState;
    }
  }
  if (typeof action === "object") {
    return prevState;
  }
  if (action === "Init") {
    return prevState;
  }
  var promise = Task.fetchAll();
  return {
          TAG: "Loading",
          _0: promise.then(function (tasks) {
                actionSignal$1.value = {
                  TAG: "Fetched",
                  _0: tasks
                };
                return Promise.resolve(tasks);
              })
        };
}

var stateSignal = Signals.signal("Empty");

var transitionSignal = Signals.signal({
      prev: "Empty",
      next: "Empty",
      action: "Init",
      created_at: DateTime.now()
    });

Signals.effect(function () {
      var action = actionSignal$1.value;
      var prevState = stateSignal.peek();
      var nextState = reduce$2(prevState, action);
      if (prevState !== nextState) {
        Signals.batch(function () {
              stateSignal.value = nextState;
              transitionSignal.value = {
                prev: prevState,
                next: nextState,
                action: action,
                created_at: DateTime.now()
              };
            });
      }
      
    });

function dispatch$1(action) {
  actionSignal$1.value = action;
}

var TasksFSM = {
  actionSignal: actionSignal$1,
  reduce: reduce$2,
  stateSignal: stateSignal,
  transitionSignal: transitionSignal,
  dispatch: dispatch$1
};

function serializable_encode(v) {
  return Js_dict.fromArray(Spice.filterOptional([
                  [
                    "appState",
                    Spice.stringToJson(v.appState)
                  ],
                  [
                    "subState",
                    Spice.stringToJson(v.subState)
                  ],
                  [
                    "data",
                    (function (v) {
                          return v;
                        })(v.data)
                  ]
                ]));
}

function serializable_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (!(typeof v === "object" && !Array.isArray(v))) {
    return Spice.error(undefined, "Not an object", v);
  }
  var match = Belt_Option.map(Js_dict.get(v, "appState"), Spice.stringFromJson);
  if (match === undefined) {
    return Spice.error(undefined, "appState missing", v);
  }
  if (match.TAG === "Ok") {
    var match$1 = Belt_Option.map(Js_dict.get(v, "subState"), Spice.stringFromJson);
    if (match$1 === undefined) {
      return Spice.error(undefined, "subState missing", v);
    }
    if (match$1.TAG === "Ok") {
      var match$2 = Belt_Option.map(Js_dict.get(v, "data"), (function (v) {
              return {
                      TAG: "Ok",
                      _0: v
                    };
            }));
      if (match$2 === undefined) {
        return Spice.error(undefined, "data missing", v);
      }
      if (match$2.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: {
                  appState: match._0,
                  subState: match$1._0,
                  data: match$2._0
                }
              };
      }
      var e = match$2._0;
      return {
              TAG: "Error",
              _0: {
                path: ".data" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = match$1._0;
    return {
            TAG: "Error",
            _0: {
              path: ".subState" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = match._0;
  return {
          TAG: "Error",
          _0: {
            path: ".appState" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
}

var stateSignal$1 = Signals.signal("Idle");

function reduce$3(prevState, action) {
  if (typeof action !== "object") {
    return prevState;
  } else if (action.TAG === "NewTask") {
    return {
            TAG: "NewTask",
            _0: reduce$1("Inactive", action._0)
          };
  } else {
    return {
            TAG: "Task",
            _0: reduce("Inactive", action._0)
          };
  }
}

var transitionSignal$1 = Signals.signal({
      prev: "Idle",
      next: "Idle",
      action: "Init",
      created_at: DateTime.now()
    });

Signals.effect(function () {
      var action = actionSignal.value;
      var prevState = stateSignal$1.peek();
      var nextState = reduce$3(prevState, action);
      if (prevState !== nextState) {
        Signals.batch(function () {
              stateSignal$1.value = nextState;
              transitionSignal$1.value = {
                prev: prevState,
                next: nextState,
                action: action,
                created_at: DateTime.now()
              };
            });
      }
      
    });

function dispatch$2(action) {
  actionSignal.value = action;
}

var AppFSM = {
  serializable_encode: serializable_encode,
  serializable_decode: serializable_decode,
  stateSignal: stateSignal$1,
  reduce: reduce$3,
  transitionSignal: transitionSignal$1,
  dispatch: dispatch$2
};

Signals.effect(function () {
      var transition = transitionSignal$1.value;
      var state = transition.next;
      if (typeof state === "object" && state.TAG !== "Task") {
        var state$1 = state._0;
        if (typeof state$1 === "object" && state$1.TAG === "Active") {
          var encodedTask = Task.task_encode(state$1._0);
          var dict = {
            appState: "NewTask",
            subState: "Active",
            data: encodedTask
          };
          var json = JSON.stringify(serializable_encode(dict));
          console.log("encoded", json);
        }
        
      }
      console.log("transition", transition);
    });

export {
  Actions ,
  actionSignal ,
  TaskFSM ,
  NewTaskFSM ,
  TasksFSM ,
  AppFSM ,
}
/* actionSignal Not a pure module */
