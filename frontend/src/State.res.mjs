// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Task from "./Task.res.mjs";
import * as Spice from "@greenlabs/ppx-spice/src/rescript/Spice.res.mjs";
import * as DateTime from "./DateTime.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Signals from "@preact/signals";

var Task$1 = {};

var NewTask = {};

var Tasks = {};

var App = {};

var Actions = {
  Task: Task$1,
  NewTask: NewTask,
  Tasks: Tasks,
  App: App
};

var actionSignal = Signals.signal("Init");

function reduce(prevState, action) {
  var exit = 0;
  if (typeof action !== "object") {
    if (action === "Init") {
      return prevState;
    }
    exit = 2;
  } else {
    exit = 2;
  }
  if (exit === 2) {
    if (typeof prevState !== "object") {
      if (typeof action !== "object" || action.TAG !== "Open") {
        return prevState;
      } else {
        return {
                TAG: "Fetching",
                _0: Task.fetchTask(action._0)
              };
      }
    }
    switch (prevState.TAG) {
      case "Fetching" :
          if (typeof action !== "object" || action.TAG !== "Fetched") {
            return prevState;
          } else {
            return {
                    TAG: "Idle",
                    _0: action._0
                  };
          }
      case "Error" :
          break;
      case "Idle" :
          if (typeof action !== "object") {
            if (action === "ClockIn") {
              return {
                      TAG: "Running",
                      _0: prevState._0,
                      _1: {
                        id: "",
                        start_time: DateTime.now(),
                        end_time: undefined,
                        notes: "",
                        interrupted_by_task_id: undefined
                      }
                    };
            } else {
              return prevState;
            }
          }
          switch (action.TAG) {
            case "Open" :
                return prevState;
            case "Fetched" :
                break;
            case "UpdateTask" :
                return {
                        TAG: "Idle",
                        _0: action._0
                      };
            
          }
          break;
      case "Running" :
          var session = prevState._1;
          var task = prevState._0;
          if (typeof action !== "object") {
            if (action === "ClockIn") {
              return prevState;
            } else {
              return {
                      TAG: "Idle",
                      _0: {
                        id: task.id,
                        title: task.title,
                        notes: task.notes,
                        estimated_time: task.estimated_time,
                        estimated_time_map: task.estimated_time_map,
                        due_date: task.due_date,
                        completed_at: task.completed_at,
                        created_at: task.created_at,
                        updated_at: task.updated_at,
                        parent_task_id: task.parent_task_id,
                        tracked_time: task.tracked_time,
                        time_sessions: Belt_Array.concatMany([
                              task.time_sessions,
                              [{
                                  id: session.id,
                                  start_time: session.start_time,
                                  end_time: DateTime.now(),
                                  notes: session.notes,
                                  interrupted_by_task_id: session.interrupted_by_task_id
                                }]
                            ])
                      }
                    };
            }
          }
          switch (action.TAG) {
            case "Open" :
                return prevState;
            case "Fetched" :
                break;
            case "UpdateTask" :
                return {
                        TAG: "Running",
                        _0: action._0,
                        _1: session
                      };
            
          }
          break;
      
    }
  }
  return prevState;
}

function dispatch(action) {
  actionSignal.value = {
    TAG: "OpenTask",
    _0: action
  };
}

var TaskFSM = {
  reduce: reduce,
  dispatch: dispatch
};

function title(draft, title$1) {
  return {
          title: title$1,
          notes: draft.notes,
          estimated_time_map: draft.estimated_time_map,
          due_date: draft.due_date,
          parent_task_id: draft.parent_task_id
        };
}

function estimatedTimeHours(draft, hours) {
  var init = draft.estimated_time_map;
  return {
          title: draft.title,
          notes: draft.notes,
          estimated_time_map: {
            hours: hours,
            minutes: init.minutes
          },
          due_date: draft.due_date,
          parent_task_id: draft.parent_task_id
        };
}

function estimatedTimeMinutes(draft, minutes) {
  var init = draft.estimated_time_map;
  return {
          title: draft.title,
          notes: draft.notes,
          estimated_time_map: {
            hours: init.hours,
            minutes: minutes
          },
          due_date: draft.due_date,
          parent_task_id: draft.parent_task_id
        };
}

function dueDate(draft, due_date) {
  return {
          title: draft.title,
          notes: draft.notes,
          estimated_time_map: draft.estimated_time_map,
          due_date: due_date,
          parent_task_id: draft.parent_task_id
        };
}

function parentTask(draft, parent_task_id) {
  return {
          title: draft.title,
          notes: draft.notes,
          estimated_time_map: draft.estimated_time_map,
          due_date: draft.due_date,
          parent_task_id: parent_task_id
        };
}

function notes(draft, notes$1) {
  return {
          title: draft.title,
          notes: notes$1,
          estimated_time_map: draft.estimated_time_map,
          due_date: draft.due_date,
          parent_task_id: draft.parent_task_id
        };
}

var Reducers = {
  title: title,
  estimatedTimeHours: estimatedTimeHours,
  estimatedTimeMinutes: estimatedTimeMinutes,
  dueDate: dueDate,
  parentTask: parentTask,
  notes: notes
};

function reduce$1(prevState, action) {
  if (typeof action !== "object" && action === "Init") {
    return prevState;
  }
  if (typeof prevState !== "object") {
    if (typeof action !== "object" && action === "Create") {
      return {
              TAG: "Active",
              _0: {
                title: "",
                notes: "",
                estimated_time_map: {
                  hours: 0,
                  minutes: 20
                },
                due_date: undefined,
                parent_task_id: undefined
              }
            };
    } else {
      return prevState;
    }
  }
  if (prevState.TAG !== "Active") {
    if (typeof action !== "object" || action.TAG !== "Saved") {
      return prevState;
    } else {
      return "Inactive";
    }
  }
  var draft = prevState._0;
  if (typeof action !== "object") {
    if (action === "Create") {
      return prevState;
    }
    var promise = Task.createTask(draft);
    return {
            TAG: "Saving",
            _0: promise.then(function (task) {
                  actionSignal.value = {
                    TAG: "NewTask",
                    _0: {
                      TAG: "Saved",
                      _0: task
                    }
                  };
                  return Promise.resolve(task);
                })
          };
  } else {
    if (action.TAG !== "Update") {
      return prevState;
    }
    var field = action._0;
    var tmp;
    switch (field.TAG) {
      case "Title" :
          tmp = title(draft, field._0);
          break;
      case "EstimateHours" :
          tmp = estimatedTimeHours(draft, field._0);
          break;
      case "EstimateMinutes" :
          tmp = estimatedTimeMinutes(draft, field._0);
          break;
      case "Notes" :
          tmp = notes(draft, field._0);
          break;
      case "ParentTask" :
          tmp = parentTask(draft, field._0);
          break;
      case "DueDate" :
          tmp = dueDate(draft, field._0);
          break;
      
    }
    return {
            TAG: "Active",
            _0: tmp
          };
  }
}

var NewTaskFSM = {
  Reducers: Reducers,
  reduce: reduce$1
};

var actionSignal$1 = Signals.signal("Init");

function reduce$2(prevState, action) {
  if (typeof prevState === "object") {
    if (prevState.TAG === "Loading" && typeof action === "object") {
      return {
              TAG: "Tasks",
              _0: {
                tasks: action._0
              }
            };
    } else {
      return prevState;
    }
  }
  if (typeof action === "object") {
    return prevState;
  }
  if (action === "Init") {
    return prevState;
  }
  var promise = Task.fetchAll();
  return {
          TAG: "Loading",
          _0: promise.then(function (tasks) {
                actionSignal$1.value = {
                  TAG: "Fetched",
                  _0: tasks
                };
                return Promise.resolve(tasks);
              })
        };
}

var stateSignal = Signals.signal("Empty");

var transitionSignal = Signals.signal({
      prev: "Empty",
      next: "Empty",
      action: "Init",
      created_at: DateTime.now()
    });

Signals.effect(function () {
      var action = actionSignal$1.value;
      var prevState = stateSignal.peek();
      var nextState = reduce$2(prevState, action);
      if (prevState !== nextState) {
        Signals.batch(function () {
              stateSignal.value = nextState;
              transitionSignal.value = {
                prev: prevState,
                next: nextState,
                action: action,
                created_at: DateTime.now()
              };
            });
      }
      
    });

function dispatch$1(action) {
  actionSignal$1.value = action;
}

function getTasks() {
  var state = stateSignal.value;
  if (typeof state !== "object") {
    return [];
  } else if (state.TAG === "Loading") {
    return [];
  } else {
    return state._0.tasks;
  }
}

var TasksFSM = {
  actionSignal: actionSignal$1,
  reduce: reduce$2,
  stateSignal: stateSignal,
  transitionSignal: transitionSignal,
  dispatch: dispatch$1,
  getTasks: getTasks
};

var stateSignal$1 = Signals.signal("Idle");

function reduce$3(prevState, action) {
  if (typeof action !== "object") {
    return prevState;
  }
  action.TAG === "NewTask";
  if (typeof prevState !== "object") {
    if (typeof action === "object") {
      if (action.TAG === "NewTask") {
        return {
                TAG: "NewTask",
                _0: reduce$1("Inactive", action._0)
              };
      } else {
        return {
                TAG: "Task",
                _0: reduce("Inactive", action._0)
              };
      }
    }
    
  } else if (prevState.TAG === "Task") {
    if (typeof action === "object") {
      if (action.TAG === "NewTask") {
        return {
                TAG: "NewTask",
                _0: reduce$1("Inactive", action._0)
              };
      } else {
        return {
                TAG: "Task",
                _0: reduce("Inactive", action._0)
              };
      }
    }
    
  } else if (typeof action === "object") {
    if (action.TAG === "NewTask") {
      return {
              TAG: "NewTask",
              _0: reduce$1(prevState._0, action._0)
            };
    } else {
      return {
              TAG: "Task",
              _0: reduce("Inactive", action._0)
            };
    }
  }
  
}

var transitionSignal$1 = Signals.signal({
      prev: "Idle",
      next: "Idle",
      action: "Init",
      created_at: DateTime.now()
    });

Signals.effect(function () {
      var action = actionSignal.value;
      var prevState = stateSignal$1.peek();
      var nextState = reduce$3(prevState, action);
      if (prevState !== nextState) {
        Signals.batch(function () {
              stateSignal$1.value = nextState;
              transitionSignal$1.value = {
                prev: prevState,
                next: nextState,
                action: action,
                created_at: DateTime.now()
              };
            });
      }
      
    });

function dispatch$2(action) {
  actionSignal.value = action;
}

var AppFSM = {
  stateSignal: stateSignal$1,
  reduce: reduce$3,
  transitionSignal: transitionSignal$1,
  dispatch: dispatch$2
};

function newTaskState_encode(v) {
  if (typeof v !== "object") {
    return ["Init"];
  } else {
    return [
            "Active",
            Task.draft_encode(v._0)
          ];
  }
}

function newTaskState_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  var match = Belt_Array.getExn(v, 0);
  if (!(!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean") && typeof match === "string") {
    switch (match) {
      case "Active" :
          if (v.length !== 2) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          }
          var v0 = Task.draft_decode(Belt_Array.getExn(v, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Active",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Init" :
          if (v.length !== 1) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Init"
                  };
          }
      default:
        
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

function taskState_encode(v) {
  if (typeof v !== "object") {
    return ["Init"];
  } else {
    return [
            "Selected",
            Spice.stringToJson(v._0)
          ];
  }
}

function taskState_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  var match = Belt_Array.getExn(v, 0);
  if (!(!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean") && typeof match === "string") {
    switch (match) {
      case "Init" :
          if (v.length !== 1) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Init"
                  };
          }
      case "Selected" :
          if (v.length !== 2) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          }
          var v0 = Spice.stringFromJson(Belt_Array.getExn(v, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Selected",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      default:
        
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

function t_encode(v) {
  if (typeof v !== "object") {
    return ["Idle"];
  } else if (v.TAG === "Task") {
    return [
            "Task",
            taskState_encode(v._0)
          ];
  } else {
    return [
            "NewTask",
            newTaskState_encode(v._0)
          ];
  }
}

function t_decode(v) {
  if (!Array.isArray(v) && (v === null || typeof v !== "object") && typeof v !== "number" && typeof v !== "string" && typeof v !== "boolean") {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  var match = Belt_Array.getExn(v, 0);
  if (!(!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean") && typeof match === "string") {
    switch (match) {
      case "Idle" :
          if (v.length !== 1) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          } else {
            return {
                    TAG: "Ok",
                    _0: "Idle"
                  };
          }
      case "NewTask" :
          if (v.length !== 2) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          }
          var v0 = newTaskState_decode(Belt_Array.getExn(v, 1));
          if (v0.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "NewTask",
                      _0: v0._0
                    }
                  };
          }
          var e = v0._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e.path,
                    message: e.message,
                    value: e.value
                  }
                };
      case "Task" :
          if (v.length !== 2) {
            return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
          }
          var v0$1 = taskState_decode(Belt_Array.getExn(v, 1));
          if (v0$1.TAG === "Ok") {
            return {
                    TAG: "Ok",
                    _0: {
                      TAG: "Task",
                      _0: v0$1._0
                    }
                  };
          }
          var e$1 = v0$1._0;
          return {
                  TAG: "Error",
                  _0: {
                    path: "[0]" + e$1.path,
                    message: e$1.message,
                    value: e$1.value
                  }
                };
      default:
        
    }
  }
  return Spice.error(undefined, "Invalid variant constructor", Belt_Array.getExn(v, 0));
}

var Serialize = {
  newTaskState_encode: newTaskState_encode,
  newTaskState_decode: newTaskState_decode,
  taskState_encode: taskState_encode,
  taskState_decode: taskState_decode,
  t_encode: t_encode,
  t_decode: t_decode
};

Signals.effect(function () {
      var transition = transitionSignal$1.value;
      var state = transition.next;
      if (typeof state === "object" && state.TAG !== "Task") {
        var state$1 = state._0;
        if (typeof state$1 === "object" && state$1.TAG === "Active") {
          var data = {
            TAG: "NewTask",
            _0: {
              TAG: "Active",
              _0: state$1._0
            }
          };
          var encoded = t_encode(data);
          var json = JSON.stringify(encoded);
          console.log("json", json);
        }
        
      }
      console.log("transition", transition);
    });

export {
  Actions ,
  actionSignal ,
  TaskFSM ,
  NewTaskFSM ,
  TasksFSM ,
  AppFSM ,
  Serialize ,
}
/* actionSignal Not a pure module */
