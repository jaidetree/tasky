// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Task from "./Task.res.mjs";
import * as DateTime from "./DateTime.res.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Signals from "@preact/signals";

var actionSignal = Signals.signal("Init");

var stateSignal = Signals.signal("Inactive");

var transitionSignal = Signals.computed(function () {
      var action = actionSignal.value;
      var prevState = stateSignal.peek();
      var nextState;
      var exit = 0;
      var exit$1 = 0;
      if (typeof action !== "object" && action === "Init") {
        nextState = prevState;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (typeof prevState !== "object") {
          nextState = typeof action !== "object" || action.TAG !== "Fetch" ? prevState : ({
                TAG: "Fetching",
                _0: Task.fetchTask(action._0)
              });
        } else {
          switch (prevState.TAG) {
            case "Fetching" :
                nextState = typeof action !== "object" || action.TAG !== "Fetched" ? prevState : ({
                      TAG: "Idle",
                      _0: action._0
                    });
                break;
            case "Error" :
                exit = 1;
                break;
            case "Idle" :
                if (typeof action !== "object") {
                  nextState = action === "ClockIn" ? ({
                        TAG: "Running",
                        _0: prevState._0,
                        _1: {
                          id: "",
                          started_at: DateTime.now(),
                          ended_at: undefined,
                          interrupted_by_task_id: undefined,
                          notes: ""
                        }
                      }) : prevState;
                } else {
                  switch (action.TAG) {
                    case "Fetch" :
                        nextState = prevState;
                        break;
                    case "Fetched" :
                        exit = 1;
                        break;
                    case "UpdateTask" :
                        nextState = {
                          TAG: "Idle",
                          _0: action._0
                        };
                        break;
                    
                  }
                }
                break;
            case "Running" :
                var session = prevState._1;
                var task = prevState._0;
                if (typeof action !== "object") {
                  nextState = action === "ClockIn" ? prevState : ({
                        TAG: "Idle",
                        _0: {
                          id: task.id,
                          name: task.name,
                          notes: task.notes,
                          parent_task_id: task.parent_task_id,
                          estimated_time: task.estimated_time,
                          time_sessions: Belt_Array.concatMany([
                                task.time_sessions,
                                [{
                                    id: session.id,
                                    started_at: session.started_at,
                                    ended_at: DateTime.now(),
                                    interrupted_by_task_id: session.interrupted_by_task_id,
                                    notes: session.notes
                                  }]
                              ]),
                          tasks: task.tasks
                        }
                      });
                } else {
                  switch (action.TAG) {
                    case "Fetch" :
                        nextState = prevState;
                        break;
                    case "Fetched" :
                        exit = 1;
                        break;
                    case "UpdateTask" :
                        nextState = {
                          TAG: "Running",
                          _0: action._0,
                          _1: session
                        };
                        break;
                    
                  }
                }
                break;
            
          }
        }
      }
      if (exit === 1) {
        nextState = prevState;
      }
      if (prevState !== nextState) {
        stateSignal.value = nextState;
      }
      return {
              prev: prevState,
              next: nextState,
              action: action
            };
    });

function dispatch(action) {
  actionSignal.value = action;
}

var TaskFSM = {
  actionSignal: actionSignal,
  stateSignal: stateSignal,
  transitionSignal: transitionSignal,
  dispatch: dispatch
};

var actionSignal$1 = Signals.signal("Init");

var stateSignal$1 = Signals.signal("Inactive");

var transitionSignal$1 = Signals.computed(function () {
      var action = actionSignal$1.value;
      var prevState = stateSignal$1.peek();
      var nextState;
      var exit = 0;
      if (typeof action !== "object" && action === "Init") {
        nextState = prevState;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (typeof prevState !== "object") {
          nextState = typeof action !== "object" && action === "NewTask" ? ({
                TAG: "Active",
                _0: {
                  id: "",
                  name: "",
                  notes: "",
                  parent_task_id: undefined,
                  estimated_time: 0,
                  time_sessions: [],
                  tasks: []
                }
              }) : prevState;
        } else if (prevState.TAG === "Active") {
          if (typeof action !== "object") {
            if (action === "NewTask") {
              nextState = prevState;
            } else {
              var promise = Task.createTask(prevState._0);
              nextState = {
                TAG: "Saving",
                _0: promise.then(function (task) {
                      actionSignal$1.value = {
                        TAG: "Saved",
                        _0: task
                      };
                      return Promise.resolve(task);
                    })
              };
            }
          } else {
            nextState = action.TAG === "Update" ? ({
                  TAG: "Active",
                  _0: action._0
                }) : prevState;
          }
        } else {
          nextState = typeof action !== "object" || action.TAG !== "Saved" ? prevState : "Inactive";
        }
      }
      if (prevState !== nextState) {
        stateSignal$1.value = nextState;
      }
      return {
              prev: prevState,
              next: nextState,
              action: action
            };
    });

function dispatch$1(action) {
  actionSignal$1.value = action;
}

var NewTaskFSM = {
  actionSignal: actionSignal$1,
  stateSignal: stateSignal$1,
  transitionSignal: transitionSignal$1,
  dispatch: dispatch$1
};

var actionSignal$2 = Signals.signal("Init");

var stateSignal$2 = Signals.signal("Idle");

var transitionSignal$2 = Signals.computed(function () {
      var action = actionSignal$2.value;
      var prevState = stateSignal$2.peek();
      var nextState;
      if (typeof action !== "object") {
        if (action === "Init") {
          nextState = prevState;
        } else {
          actionSignal$1.value = "NewTask";
          nextState = "New";
        }
      } else {
        nextState = {
          TAG: "Task",
          _0: action._0
        };
      }
      if (prevState !== nextState) {
        stateSignal$2.value = nextState;
      }
      return {
              prev: prevState,
              next: nextState,
              action: action
            };
    });

function dispatch$2(action) {
  actionSignal$2.value = action;
}

var AppFSM = {
  actionSignal: actionSignal$2,
  stateSignal: stateSignal$2,
  transitionSignal: transitionSignal$2,
  dispatch: dispatch$2
};

export {
  TaskFSM ,
  NewTaskFSM ,
  AppFSM ,
}
/* actionSignal Not a pure module */
